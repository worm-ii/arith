     ----------------------------------------------------------------
        Библиотека арифметики высокой точности - краткая информация
                   по состоянию на 3 февраля l999 года
     ----------------------------------------------------------------

                           (C) Worm II, 1993 :), 99

Этот документ содержит сведения, нагло выдаваемые за
документацию по библиотеке арифметики высокой точности
для 32-bit Borland Delphi версии 2.03 alpha confidential build
specially for Andrew Luckovenko, обзываемой в дальнейшем БАВТ.

[Содержание skipped]

[Советы по использованию этого документа skipped]

[GREETINGS TO... skipped]

[Краткое содержание предыдущих серий skipped]

[DISCLAIMER skipped]

[Тяжела и неказиста... skipped]

Короче, help пока under development, читайте что есть.



Общие сведения
==============

БАВТ предназначена для выполнения основных математических операций
над числами высокой точности.

Требования:

- Процессор - 80386 и выше с математическим сопроцессором
- Операционная система - Windows 95, Windows NT или совместимая
- Borland Delphi 1.0 (32-битная версия) или выше
  (проверял на 1-м и 4-м)

Характеристики:

- изменяемая точность чисел (от 3 до 10000 значащих десятичных цифр);
- наибольшее представляемое число: ~ 10^100000000
- наименьшее представляемое положительное число: 10^-100000000
- поддерживается набор основных математических операций :
  4 арифметических действия, деление с остатком, возведение в степень,
  квадратный корень, логарифм, экспонента, (ко)синус, арктангенс;
  число «пи».

[Комплектация skipped]



Как работать с библиотекой
==========================

Ядром библиотеки является объект TNum. Этот объект представляет число
с изменяемой точностью. Чтобы создать объект, вызовите конструктор
Create с числовым параметром, указывающим начальную точность числа
(количество верных десятичных цифр, 3..10000).

Фундаментальные свойства:

DecPrec: TDecPrec = 3..10000
Sign: TSign = (Zero, Positive, Negative) (не надейтесь на Ord(Sign))!
BinExp: -MaxBinExp..MaxBinExp ~= 300 млн.
DecExp: TDecExp = -MaxDecExp..MaxDecExp = 99999999
DecDigits[Index: Integer = 0..DecPrec-1]: TDecDigit = 0..9
DecChars[Index: Integer = 0..DecPrec-1]: TDecChar = '0'..'9'
QWordDigits[Index: Integer = 0..QWordPrec-1]: QWord = (Lo,Hi: DWord)
  QWordDigits - внутреннее двоичное представление числа. Подробнее
  о внутреннем представлении чисел см. далее.

Значение числа можно определить как S * X.XX...X * 2^DecExp, где:

S = -1, если Sign = Negative;
    +1, если Sign = Positive;
     0, если Sign = Zero;
X.XX...X - DecDigits[0].DecDigits[1..DecPrec-1], причём
DecDigits[0] = 0 тогда и только тогда, когда Sign = Zero.

Аналогичным образом определяется значение числа по двоичному
представлению.


Свойства объекта AsString AsInteger, AsInt64 (для D123: Int64=QWord),
AsFloat и AsComp используются для чтения и записи значения объекта в
соответствующем формате. Для определения, входит ли значение объекта
в диапазон соответствующего типа, используйте свойства IsInteger,
IsInt64, IsExtended и IsComp типа Boolean. Методы объекта Sum, Prod,
Diff и Quot принимают по 2 аргумента типа TNum и присваивают объекту
значения соответственно суммы, произведения аргументов, разности между
первым и вторыми частного от деления первого на второй. Для сравнения
используйте методы Eq, GT, LT, GE, LE. Для обнуления значения числа
лучше всего использовать: Sign := Zero. Внимание! Свойство AsInteger
при чтении не производит никаких округлений, и если число - не целое,
вызывает исключение! Аналогично с другими целыми свойствами (Int64,
Comp). Если приспичило округлять - юзайте IntTrunc, IntRound, etc
(см. далее).

Деструктор Destroy, как обычно, уничтожает экземпляр объекта.

Пример:

var A,B,C,D: TNum;

begin
  A := TNum.Create(5);     { 5 значащих цифр }
  B := TNum.Create(4);
  C := TNum.Create(3);
  D := TNum.Create(10);
  try
    A.AsString := '3';       { A := 3 }
    B.AsString := '2.15e-1'; { B := 0.215 }
    C.AsInteger := 10;       { C := 10 }
    D.AsFloat := 1.5e3;      { D := 1500 }
    A.Sum(B,C);              { A := B-C (-9.785) }
    B.Prod(A,D);             { B := A*D (-14677.5 округляется до -14680.0) }
    D.Quot(C,B);             { D := C/B (0.0006811989101) }
    WriteLn(D.AsString);     { 6.811989101e-00000004 }
    D.Quot(A,0);             { Exception ENumDivByZero }
  finally
    A.Destroy;
    B.Destroy;
    C.Destroy;
    D.Destroy;
  end;
end.


Константы
=========

Для упрощения работы вводятся константы. При попытке изменить значение
константы происходит исключение. Как создавать константы - см. исходник
Const_00.pas и конструктор CreateConst в ArKrnl.pas. Кстати,
Const_00.pas содержит константы, необходимые для внутренней работы самой
библиотеки и поскольку точность требуется свыше 10000 дес. знаков, этот
модуль весьма тяжёл (по объёму - бОльшая часть библиотеки, около 120К
в скомпилированном виде, полметра в исходниках).

Далее, Можно ещё использовать строковые и числовые (Extended) константы
в стандартных методах (для продвинутых юзеров: это внутри этого метода
они константы, а для программы - могут быть и переменными :).

Пример для счастливых обладателей Delphi 4.0+ (перегрузка, однако!):

  A.Quot(5.52,A);
  if B.GE(45) then B.Sum('10',5);

Для остальных вводятся постфиксы: постфикс E означает, что последний
параметр - типа Extended, ER (R=Reverse) - что первый параметр
типа Extended, EE - что 2 параметра этого типа. Задача для особенно
продвинутых гуру: что означают постфиксы S, SR, SS, ES и SE, и почему
есть методы DiffER и DiffSE, но нет методов SumER и SumSE? :)

  A.QuotER(5.52,A);
  if B.GEE(45) then B.SumSE('10',5);

Определена константа numPi.

  A.Diff(numPi,numPi); { попытайтесь отгадать результат :) }
  numPi.Sum(A,B); { Exception ENumConst. Мда, надо бы название получше... }

Точность констант при вычислениях всегда максимальна, даже если она
задана маленькой! Непонятно? Сам еле понял ;)


Математические функции
======================

Методы:

Abs_
ArcTan_
Ceil_ - не работает
ChS (Change Sign: Self := - Argument)
Cos_
DivMod
Exp_
Floor_ - не работает
Frac_
IntPower
Int_
Ln_
Power
Round_
Sin_
Sqrt_
Trunc_ = Int_

Odd_ - функция, возвращающая Boolean
  ( На самом деле Odd_ не проверяет целость числа, а возвращает
    нечётность целой части (IntTrunc) числа )
IntTrunc - функция, возвращающая Integer
IntRound - -- " --
IntCeil - -- " --
IntFloor - -- " --

Константы:
numZero, numOne, numMinusOne, numTwo, numHalf, numTen, numPi

Надеюсь, в основном назначение этих методов и констант понятно.
О методах округлений (Trunc, etc.) см. help по соответствующим
паскалевским функциям.
Примеры:

  A.Cos_(B); { в радианах! }
  A.ExpS('1000000000') { всему приходит свой предел... ENumOverflow }
  C.Ln_(-1); { ENumInvalidArg }
  A.IntPower(C,20); { эквивалентно  A.PowerE(C,20) }
  { кстати, Power по возможности юзает IntPower }
  A.DivModSR('10',numPi,C); { A=10 div Pi, C=10 mod Pi, C: TNum или nil }



Другие методы
=============

procedure Copy(X: TNum) - копирует значение аргумента. Результат
  помещается в объект ( Self := X ). Если точность назначения меньше
  точности источника, то происходит округление (к ближайшему) При
  этом может возникнуть исключение «Переполнение» (ENumOverflow).
  Например: 9.97e+99999999 -> 1.0e+100000000.

procedure Val_(var P: PChar; NumEnd0: Boolean) - читает из
  ASCIIZ-строки P число, запихивает его в объект. Если NumEnd0 = True,
  то после числа ничего не должно стоять, иначе может, в этом случае
  указатель P передвигается на следующий символ после прочитанного
  числа (это удобно при разборе выражений). Кстати, AsString его
  пользует. См. также ENumValError.



Исключения
==========


Иерархия классов исключений:

ENum +
     |- ENumConvertError
     |- ENumDivByZero
     |- ENumInvalidArg
     |- ENumOverflow
     |- ENumValError
     +- ENumConst

Исключение ENum - это базовый класс исключений библиотеки. Оно возникает
в ситуациях, не вызванных непосредственно числовым переполнением или
неправильными параметрами, передаваемыми математическим функциям.
В большинстве случаев это исключение возникает при обнаружении
внутренней ошибки в библиотеке, однако не всегда.


Исключение ENumConvertError указывает на особую ситуацию преобразования
числа в другой тип.
Данное исключение возникает, когда производится чтение свойств AsInteger,
AsInt64, AsFloat, AsComp и число не может быть представлено в
соответствующем формате (не входит в диапазон представления данного
типа). Этого можно избежать, если предварительно воспользоваться
свойствами (соответственно): IsInteger, IsInt64, IsExtended, IsComp.


Исключение ENumDivByZero указывает на особую ситуацию деления на нуль.
Оно возникает при выполнении методов Quot (если делимое равно нулю),
IntPower (если основание степени - нуль и показатель отрицателен).


Исключение ENumInvalidArg указывает на неверные аргументы
математических функций. Оно возникает при выполнении методов Quot
(если и делимое и делитель - нули), IntPower (если и основание и
показатель степени - нули), Power (если основание степени не больше
нуля), Ln_ (если аргумент не больше нуля), Sqrt_ (если аргумент
отрицателен).


Исключение ENumOverflow указывает на особую ситуацию переполнения
(выхода результата за пределы поддерживаемого диапазона). Данное
исключение возникает при выполнении многих методов, как в результате
получения слишком большого результата (Exp_, Prod, и т.д.), так и в
результате округления, ведь вполне может случиться, что округление
приведёт к выходу за пределы поддерживаемого диапазона. Застрахованы
от этого исключения лишь методы, возвращающие результат, всегда лежащий
в определённых пределах (не зависящих от аргументов), например: ArcTan_,
Frac_ и др.


Исключение ENumValError указывает на неверную строковую запись числа.

ENumValError = class(ENum)
  property ErrorPos: PChar;
end;

Данное исключение возникает при записи свойства AsString и при
выполнении метода Val_. Причина -в неверной записи числа, например,
--2, 12.34.56 или 73.12e-0076543210 (превышена максимальная длина
показателя степени, равная 8). Свойство ErrorPos - указатель на символ,
чтение которого вызвало исключение. Удобно? Дык!


Исключение ENumConst возникает при любой попытке изменения числа,
являющегося константой (на это указывает read-only свойство IsConst).



Внутреннее представление
========================

Есть два представления для числа: десятичное (оно уже рассматривалось)
и двоичное. Рассмотрим теперь подробнее двоичное представление.

Число представляется в виде массива из QWordPrec "цифр". "Цифрой" мы
здесь называем 64-битное беззнаковое целое, располагающееся
в 8-ми последовательных байтах памяти, причём младшие байты идут
в начале (имеют меньший адрес), а старшие - в конце (QWord). Аналогично,
сами "цифры" идут в том же порядке: младшие в начале, старшие - в конце.
Значение такого числа можно определить как (X = Self.QWordDigits):
  ( X[0]+2^64*X[1]+2^128*X[2]+...+(2^(64*(Count-1)))*X[Count-1] ) * 2^K,
где масштабный множитель 2^K определяет положение плавающей точки внутри
мантиссы, причём K = BinPrec + 1 - 64*Count, то есть если число не равно
нулю и BinPrec = 0, то число имеет величину 1 <= Value < 2 (старший бит
старшего четверного слова всегда равен единице, если только всё число
не равно нулю, а остальные биты представляют дробные десятичные разряды).

Двоичное и десятичное представления всегда согласованы между собой.
При записи, например, свойства AsString (десятичная запись) активизируется
десятичное представление числа, и сбрасывается внутренний флаг верности
двоичного представления. Если затем востребуется двоичное представление,
то при сброшенном состоянии этого внутреннего флага происходит
восстановление двоичного представления из десятичного и флаг
устанавливается. И наоборот, есть внутренний флаг верности десятичного
представления, который используется в аналогичных ситуациях.

Все вычисления (за исключением простейших функций типа Abs_, ChS)
проводятся, разумеется, в двоичном представлении.

Вся эта чушь почти прозрачна для юзера, но следует иметь в виду, что
в случае, если верно десятичное представление, запись (уменьшение)
свойства DecPrec будет осуществляться по другому алгоритму (прямое
усечение десятичного представления), чем если оно неверно (усечение
двоичного представления, может и не привести к изменению представления
вовсе).

Далее, умножение и деление построены на алгоритмах "столбиком". По
моим расчётам, это обеспечивает максимальную скорость при точности до
2000 десятичных цифр, дальше они могут оказаться хуже более продвинутых
методов.

Все остальные функции используют стандартные, оптимизированные алгоритмы.
Я вообще надеюсь, что по скорости данная библиотека превосходит все
аналоги |-)Ж Впрочем, предоставляю проверку сего наглого утверждения
читателю :)

Низкоуровневые процедуры писаны на асме. Я не вижу смысла переписывать их
на Pascal, ибо всё равно всё слишком заточено под конкретный процессор
(точнее, сопроцессор - см. LowLevel.inc: procedure DivQWords). Хотя,
пожалуй, то, что вне LowLevel.inc - вполне портабельно (а зато как он
комментирован! :).


ЧТО ЕЩЁ
=======

Пример использования - ArStacks.pas, на базе которого написан простейший
калькулятор. Там, кстати, есть и реализация тангенса и арк(ко)синуса в
порождённом классе.

Относительно глюков... Я был бы весьма удивлён, если вдруг обнаружится
ошибка в основных 4-х арифметических действиях. В остальных методах -
возможны не вполне точные результаты (особенно ближе к максимальной
точности - долго тестировать :( ), хотя вроде старался обоснованно
рассчитывать точность, необходимую для расчётов, не столь простой
это вопрос... Разумеется, это не относится к случаям, когда точность
падает либо по причинам чисто математического характера ( например,
Tan(Arctan(1e1000000)) ), либо по вполне обоснованным причинам другого
рода (ну не знаю я, как считать Sin(1e1000000), если не знать числа Pi
с точностью более миллиона десятичных знаков. Хотя нет, знаю - формулы
n-кратного угла. Но тут бы потребовалось значительное время, да и
кому это надо, да и ВЛОМЫ, наконец!).

Кстати, ещё о точности, ежели не достал уже ;) В некоторых случаях,
когда известно, что точность результата мала настолько, что его можно
считать нулём, я его обнуляю. Относительно точного алгоритма подобного
безобразия - см. ArKrnl.pas: procedure CheckZero.

Всё, надоело писать!

[Все упомянутые в этом документе (зарегистрированные) торговые... skipped]
